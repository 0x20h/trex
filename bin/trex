#!/usr/bin/env python
# -*- coding: utf-8 -*-

from subprocess import call, check_output
import os, uuid, json, argparse, codecs

"""
record a new terminal session.
"""
def record(args):
  prefix = 'trex_'
  [rows, cols] = term_size()
  timing, script = [], []

  timingfile = ''.join([args.tmp, '/', prefix, str(uuid.uuid4())])
  scriptfile = ''.join([args.tmp, '/', prefix, str(uuid.uuid4())])
  
  os.system('clear')
  print "Recording..."
  
  # run script (compatible to old script versions)
  ret = os.system('script -q -t ' + scriptfile + ' 2>' + timingfile)

  if (ret):
    os.unlink(timingfile)
    os.unlink(scriptfile)
    exit(1)
  
  if encode(scriptfile, timingfile, rows, cols):
    os.unlink(timingfile)
    os.unlink(scriptfile)
  else:
    print "ERROR: encoding failed!"
  
  os.system('clear')
  print "Recording finished..."

"""
convert a script session to a trex session
"""
def convert(args):
  encode(args.scriptfile, args.timingfile, args.rows, args.cols)

"""
encode a session
"""
def encode(scriptfile, timingfile, rows, cols):
  chunks = []
  # reformat to json
  with open(timingfile, 'r') as f:
    timing = [line[:-1].split() for line in f.readlines()]
    s = open(scriptfile, 'r')
    # skip first line
    s.readline()
    chunk = ''
    acc = 0
    step = .5

    for t in timing:
      # read t[1] bytes from scriptfile
      chunk += s.read(int(t[1]))
      dur = float(t[0])

      while dur > 0:
        dur = dur - step
        delay = step if dur > 0 else step + dur

        chunks.append([
          round(delay, 3),
          chunk if dur <= 0 else "",
          1 if acc % step >= (acc + delay) % step else 0
        ])

        acc = acc + delay

      if dur < 0:
        chunk = ''

    s.close()
    f.close()
    s = json.dumps({'rows': rows, 'cols': cols, 'chunks': chunks})

  # write json file
  with open(args.outfile, 'w') as f:
    f.write(s)
    f.close()
  
  return True
    
"""
Replay a recorded trex session
"""
def replay(args):
  trex_file = json.load(open(args.file, 'r'))
  timingfile = ''.join(['/tmp', '/', 'trex_replay_timing_',
    str(uuid.uuid4())])
  scriptfile = ''.join(['/tmp', '/', 'trex_replay_script_',
    str(uuid.uuid4())])
  timing = ''

  with open(timingfile, 'w') as t:
    for element in trex_file['chunks']:
      t.write(
        str(element[0]) +
        " " +
        str(len(element[1].encode('UTF-8'))) +
        "\n"
      )
  
  with open(scriptfile, 'w') as f:
    f.write('script file generated by trex\n')
    for element in trex_file['chunks']:
      f.write(element[1].encode('UTF-8'))
    
  t.close()
  f.close()

  [rows, cols] = term_size()
  if [trex_file['rows'], trex_file['cols']] != [rows, cols]:
    print "terminal size was %sx%s when recorded. Yours is %s/%s" % \
      (trex_file['cols'], trex_file['rows'], cols, rows)
  ret = os.system('scriptreplay -t ' + timingfile + ' ' + scriptfile)
  #os.unlink(timingfile)
  #os.unlink(scriptfile)

"""
Retrieve the current terminal size
"""
def term_size():
  rows = check_output(['tput', 'lines'])[:-1]
  cols = check_output(['tput', 'cols'])[:-1]

  return [int(rows), int(cols)]

# cli setup
parser = argparse.ArgumentParser(description=('trex - a terminal recorder wrapper around `script`: '
  'This program records your current terminal session and stores it as a '
  'json encoded file in OUT_FILE. Use the generated file to playback the session in your '
  'browser using the trex jQuery plugin.'
))

subparsers = parser.add_subparsers(metavar="ACTION")
action = subparsers.add_parser('record', description="record a session", help="record a new session in OUT_FILE")
action.add_argument('outfile', metavar='OUT_FILE', type=str, help=('The JSON-encoded session file (e.g. /some/path/my-session.json)'))
action.add_argument('--tmp', metavar='DIR', type=str,
  help='tmp dir for scriptfiles [/tmp]', default='/tmp')
action.set_defaults(func=record)

action = subparsers.add_parser('replay', description="replay a session", help="replay a recorded session stored in FILE")
action.add_argument('file', metavar='FILE', type=str, help=('The JSON-encoded session file to be replayed (e.g. /some/path/my-session.json)'))
action.set_defaults(func=replay)

action = subparsers.add_parser(
  'convert',
  description="convert a script session into a trex file.",
  help="convert a script/timing file into a trex session"
)

action.add_argument('-s', '--scriptfile', metavar='FILE', type=str, required=True, help=('The scriptfile generated with `script`'))
action.add_argument('-t', '--timingfile', metavar='FILE', type=str, required=True, help=('The timing file generated with `script`'))
action.add_argument('-r', '--rows', metavar='N', type=str, required=True, help=('Terminal rows'))
action.add_argument('-c', '--cols', metavar='N', type=str, required=True, help=('Terminal columns'))
action.add_argument('outfile', metavar='OUT_FILE', type=str, help=('The JSON-encoded session file (e.g. /some/path/my-session.json)'))
action.set_defaults(func=convert)

args = parser.parse_args()
args.func(args)
